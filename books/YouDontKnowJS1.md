赵望野：作用域和闭包
梁杰：this 和对象原型

对 JavaScript 语言的印象都是简单易学，很容易上手。

如果每次遇到 JavaScript 中出乎意料的行为时，你的反应就是把它加入黑名单(很多人都 是这么做的)，那用不了多久你就会把 JavaScript 语言真正的多样性全部排除。
剩下的部分就是非常著名的“好的部分”(Good Parts)，但是亲爱的读者们，我恳请你们 把它称作“简单的部分”“安全的部分”甚至“不完整的部分”。
“你不知道的 JavaScript”系列丛书要做的事恰好相反:学习并且深入理解整个 JavaScript， 尤其是那些“难的部分”。
这个系列中的每本书专注于语言中一个最容易被误解或者最难理解的核心部分，进行深 入、详尽的介绍。在阅读本书时，你应当审视自己对于 JavaScript 的理解，仔细思考书中 讲解的理论和那些“你需要知道”的东西。
现在你所理解的 JavaScript 很可能是从别人那里学来的不完整版。这样的 JavaScript 只是真 正的 JavaScript 的影子。学完这个系列之后，你就会掌握真正的 JavaScript。读下去吧，我 的朋友，JavaScript 恭候你的光临。

传统编译语言流程中，程序中的一段源代码在执行之前会经历 3 个步骤，统称为「编译」
分词/词法分析 Tokenizing/Lexing
这个过程将字符串分解成有意义的代码块，这些代码块称为词法单元 token `var a=2;`分解为这些词法单元`var、a、=、2、;`空格是否会被当作，取决于在这门语言中是否有意义。
分词 tokenizing 和词法分析 lexing 之间的区别非常微妙、晦涩 se。**词法单元识别是通过有状态还是无状态的方式进行的**。如果**词法单元生成器**在判断 a 是一个独立的独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就称为词法分析。
**解析/语法分析 parsing**
是将词法单元流(arr)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为「抽象语法树」Abstract Syntax Tree，AST。可能会有一个 VariableDeclaration 顶级节点，接下来是一个叫做 Identifier（值是 a）的子节点，以及一个叫作 AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫做 NumericLiteral（它的值是 2）的子节点。

代码生成
将 AST 转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关。
抛开具体细节，简单来说就是有某种方法可以将 var a=2;的 AST 转化为一组机器指令，用来创建一个 a 变量（包括分配内存等等），并将一个值储存在 a 中。

关于引擎如何管理系统资源超出了我们的讨论范围，只需要简单的了解引擎可以根据需要创建并储存变量即可。

比起那些编译过程只有 3 步的语言编译器。js 引擎要复杂。在语法分析和代码生成阶段有特定步骤来对运行性能进行优化，包括对冗余元素进行优化等等。

js 引擎不会有大量（像其他语言编译器那么多的）时间用来优化，js 编译过程不是发生在构建之前的。
编译发生在执行前的几微妙。作用域背后，js 引擎佣金了各种办法（JIT，可以延迟编译甚至实施重编译）来保证性能最佳

引擎、编译器（语法分析、代码生成）、作用域（收集并维护由所有声明的标识 zhi 符（变量）组成的一系列查询，并实施一套非常严格规则，确定当前执行的代码对这些标识符的访问权限

为了能够完全理解 js 的工作原理，需要开始像引擎（和它的朋友们）一样思考，从他们的角度提出问题，并从他们的角度回答。

`var a=2;`有两个完全不同的声明，一个由编译器在编译时处理，另一个由引擎在运行时处理。
编译器首先会将这段程序分解成词法单元，然后将词法单元分解成一个树结构

1.var a,编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则他会要求作用域在当前作用域的集合中声明一个新变量，并命名为 a。 2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a=2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫做 a 的变量。如果是，引擎会使用这个变量；如果否，引擎会继续查找该变量

如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常。

总结：**变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值**

# 编译器有话说

编译器在编译过程第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是否已经声 sheng 明过。查找过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。
在我们的例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找的类型叫做 RHS。
[是一个赋值操作的左侧和右侧](https://www.da-quan.net/ti/rhs%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/)
换句话说，当变量出现在赋值操作的左侧进行 LHS 查询，出现在右侧时进行 RHS 查询。
讲的更准确一点，RHS 查询与简单地查找某个变量值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的「赋值操作右侧」，更准确地说「非左侧」。

可以将 RHS、理解成 receive his source value 取到它的源值，这意味着「得到某某的值」。让我们继续深入研究。
考虑以下代码：

```js
console.lgo(a)
```

其中对 a 的引用是一个 RHS 引用，因为这里 a 没有赋予任何值。相应地，需要查找并取得 a 的值，这样才能将值传递给`console.log(...)`

相比之下，例如
`a=2;`
这里对 a 的引用则是 LHS 引用，因为实际上我们并不关心当前值是什么，只是想要为=2 这个赋值操作找到一个目标。

LHS 和 RHS 含义是「赋值操作的左侧或右侧」，并不一定以为这就是「=赋值操作符的左侧或右侧」。赋值操作还有其他几种形式，**因此在概念上最好理解为「赋值操作的目标是谁（LHS）以及谁是赋值操作的源头（RHS）**

```js
// 既有 LHS，又有RHS引用
function foo(a) {
  console.log(a) // 2
}
foo(2)
```

最后一行 foo（。。。）函数的调用需要对 foo 进行 RHS 引用，意味着「去找到 foo 的值，并把它给我」。并且（。。。）意味着 foo 的值需要被执行，因此他最好真的是一个函数类型值。

这里还有一个容易被忽略却非常重要的细节。

代码中隐式的 a=2 操作可能很容易被你忽略掉。这个操作发生在 a 被当做参数传递给 foo（。。。）函数时，2 会被分配给参数 a。为了给参数 a（隐式地）分配值，需要进行一次 LHS 查询。

这里还有对 a 进行的 RHS 引用，并且将得到的值传给了 console.log(...) console.log(...)本身也需要一个引用才能执行，因此会对 console 对象进行 RHS 查询，并且检查得到的值中是否有一个叫做 log 的方法。

# 20/215
