作为本书的第一部分，我们在进入设计模式的学习之前，需要先了解一些相关的周边知识， 例如一些`面向对象`的基础知识、`this`等重要概念，还要掌握一些`函数式编程`的技巧。这些都是学习设计模式的必要铺垫。

# 第 1 章

`js 通过原型实现对象之间的继承,不是类式继承,没有抽象类和接口.`

## 1.1 动态类型和鸭子类型

数据类型可以把语言划分为静态类型(在编译时就已经确定变量的类型)和动态类型(程序运行的时候,待变量被赋予某个值之后才会具有某种类型)

静态类型语言的优点首先是在编译时就能发现类型...不匹配的错误,编辑器可以帮助我们确定

动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测，
我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。
这一切都建立在鸭子类型(duck typing)的概念上，鸭子类型的通俗说法是:“如果它走起 路来像鸭子，叫起来也是鸭子，那么它就是鸭子。”

这个故事告诉我们，国王要听的只是鸭子的叫声，这个声音的主人到底是鸡还是鸭并不重要。 10 鸭子类型指导我们只关注对象的行为，而不关注对象本身，也就是关注 HAS-A, 而不是 IS-A。
动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测，
我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。
这一切都建立在鸭子类型(duck typing)的概念上，鸭子类型的通俗说法是:“如果它走起 路来像鸭子，叫起来也是鸭子，那么它就是鸭子。”
我们可以通过一个小故事来更深刻地了解鸭子类型。
从前在 JavaScript 王国里，有一个国王，他觉得世界上最美妙的声音就是鸭子的叫 声，于是国王召集大臣，要组建一个 1000 只鸭子组成的合唱团。大臣们找遍了全国， 终于找到 999 只鸭子，但是始终还差一只，最后大臣发现有一只非常特别的鸡，它的叫 声跟鸭子一模一样，于是这只鸡就成为了合唱团的最后一员。

下面我们用代码来模拟这个故事。
var duck = {
duckSinging: function(){
console.log( '嘎嘎嘎' ); }
};
var chicken = {
duckSinging: function(){
console.log( '嘎嘎嘎' ); }
};

## 多态

希腊文 polymorphism poly 复数 + mouph 形态 + ism

实际含义:
同一操作作用域不同的对象上面,可以产生不同的解释和不同的执行结果.
换句话说,`给不同的对象发送同一个消息的时候,这些对象会根据这个消息分别给出不同的反馈`

这人家里讲了两只动物,一只鸭一只鸡,主任向他们发出`叫`的命令是,鸭子会'嘎嘎嘎'的叫,鸡会'咯咯咯'的叫.这两只动物都会以自己的方式发出叫声.他们同样都是动物,并且可以发出叫声.但是根据主任的命令,他们会鸽子发出不同好的叫声

var makeSound = function (animal) {
if (animal instanceof Duck) {
console.log('gagaga');
} else if (animal instanceof Chicken) {
console.log('gegege');
}
};

var Duck = function () {};
var Chicken = function () {};

makeSound(new Duck());
makeSound(new Chicken());

看起来很好,但是如果我们增加了一只狗,那么我们必须得改动 makeSound 函数,才能让狗也发出叫声...

修改代码总是危险的,修改的地方越多,程序出错的可能性就越大,动物种类增多时 makeSound 函数就会很大很大,有违常理(一个函数的行数不能太多, 不能太复杂)

实际上,我们可以将 '叫起来' 这部分打印代码 从 makeSound 里面抽出来, 也就是说, 不要在里面 if elseif else ...这样的去判断参数 animal 的原型,而是应该把 '叫起来'的打印代码 抽象成方法 放到各个动物类的原型上去

这样 makeSound() 很简单 animal.sound(); 当你添加动物的时候,在自己的原型上去加东西, 把 new 出来的实例传给 make
Sound 就行.这样,sound 方法 同样的名字,不同的实现在不同类的原型上去就行

来了一只狗,只要狗类原型上也有约定的 sound 方法就行

#### 1.2.3 类型检查和多态

全面涵盖专门针对 JavaScript 的 16 个设计模式
深入剖析面向对象设计原则、编程技巧、代码重构

人类使用名字和使用工具

足球-下底传中
each 函数迭代数组（迭代器模式）

大量相似对象，消耗较大内存-享元模式
系统中某个接口的结构已经不能适合目前需求，不想去改动被灰层遮住的老接口-适配器模式
AlloyTeam 高级前端工程师 曾探 电影音乐健身教练 腾讯 KM 论坛 JavaScript 开发模式-2012
通过对封装、继承、多态、组合等技术的反复使用
C++ 静态类型语言，但是模式社区和语言一直都在发展，与具体使用语言无关
面向对象语言、函数式语音或者其他编程范型的语言中，设计模式依然存在

Google 研究总监 Peter Norvig 动态语言设计模式 Lisp
Command 模式在 JAVA 中需要一个命令类，一个接收者类、一个调用者类。把运算块封装在命令对象的方法内，成为该对象的行为，并把命令对象四处传递。
但在 Lisp、JavaScript 这些把函数当做一等对象的语言中，函数便能封装运算块，并且函数可以被当成对象一样四处传递，这样一来，命令模式在 Lisp、
JavaScript 就成为一种隐形模式。

在 JAVA 这种静态编译型语言中，无法动态地给已存在的对象添加职责，所以一般通过包装类的方式来实现装饰者模式。但在 JavaScript 这种动态解释型语言中，
给对象动态添加职责是再简单不过的事情。这就造成了 JavaScript 语言的装饰者模式不再关注于给对象动态添加职责，而是关注于给函数动态添加职责。

# 适用性

设计模式被一些人认为是夸夸其谈的东西，这些人认为设计模式并没有多大用途。毕竟我们用普通方法就能解决的问题，使用设计模式可能会增加复杂度，或带来
一些额外代码。如果对一些设计模式使用不当，事情还可能变得更糟
从某些角度来看，设计模式确实有可能带来代码量的增加，或许也会把系统的逻辑搞得更复杂。但软件开发的成本并非全部在开发阶段，设计模式的作用是让人们写
出可复用和可维护性高的程序。假设有一个空房间，我们要日复一日地往里面放一些东西。最简单的办法当然是当然是把这些东西直接扔进去，但是时间久了，就会发现很难从这个房子里找到自己想要的东西，要调整某几样东西的位置也不容易。所以在房间里做一些柜子也许是个更好的选择，虽然柜子会增加我们的成本

第一个问题是习惯把静态类型语言的设计模式照搬到 JavaScript 中，比如有人为了模拟 JavaScript 版本的工厂方法(Factory Method)模式，而生硬地把创建对象的步骤延迟到子类中。 实际上，在 Java 等静态类型语言中，让子类来“决定”创建何种对象的原因是为了让程序迎合依 赖倒置原则(DIP)。在这些语言中创建对象时，先解开对象类型之间的耦合关系非常重要，这样 才有机会在将来让对象表现出多态性。
而在 JavaScript 这种类型模糊的语言中，对象多态性是天生的，一个变量既可以指向一个类， 又可以随时指向另外一个类。JavaScript 不存在类型耦合的问题，自然也没有必要刻意去把对象“延 迟”到子类创建，也就是说，JavaScript 实际上是不需要工厂方法模式的。模式的存在首先是能为 我们解决什么问题，这种牵强的模拟只会让人觉得设计模式既难懂又没什么用处。

设计模式并非是软件开发的专业术语。实际上，“模式”最早诞生于建筑学。20 世纪 70 年代， 哈佛大学建筑学博士 Christopher Alexander 和他的研究团队花了约 20 年的时间，研究了为解决同一 个问题而设计出的不同建筑结构，从中发现了那些高质量设计中的相似性，并且用“模式”来指 代这种相似性。
受 Christopher Alexander 工作的启发，Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides 四人(人称 Gang Of Four ，GoF)把这种“模式”观点应用于面向对象的软件设计中， 并且总结了 23 种常见的软件开发设计模式，录入《设计模式:可复用面向对象软件的基础》一书

# 20、317
