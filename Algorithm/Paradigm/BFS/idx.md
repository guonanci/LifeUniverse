宽度优先搜索-广度优先搜索是最简便的图搜索算法之一，很多重要的图算法原型。

Dijkstra 单源最短路径和 Prim 最小生成树算法都采用了和 BFS 类似的思想。属于一种盲目搜寻法，目的是系统展开并检查图中所有节点，以找寻结果。
换句话说，他并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。

Breadth First Search，并不使用经验法则算法，从算法的观点，所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中。一般的经验里，其邻居节点尚未被检验过的节点被放置在一个被称为 open 的容器中（队列或是链表），而被检验过的的节点则被放置在称为 closed 的容器中（open-closed 表）

已知图 G=（V，E）和一个源顶点 s，宽度优先搜索以一种系统的方式探寻 G 的边，从而「发现」s 所能达到的所有顶点，并计算 s 到所有这些顶点的距离（最少
边数），该算法同时能生成一颗根为 s 且包括所有可达顶点的宽度优先树

BFS 求解最短路径、最短步数上有很多应用，比如走迷宫。

在一个 n*n 的矩阵里走，从原点（0,0）开始走到终点（n-1,n-1），只能上下左右 4 个方向走，只能在给定的矩阵里走，求最短步数。n*n 是 01 矩阵，0 代表该格子没有障碍，为 1 表示有障碍物。
int mazeArr[maxn][maxn]; //表示的是 01 矩阵
int stepArr[4][2] = {{-1,0},{1,0},{0,-1},{0,1}}; //表示上下左右 4 个方向
int visit[maxn][maxn]; //表示该点是否被访问过，防止回溯，回溯很耗时。
核心代码。基本上所有的 BFS 问题都可以使用类似的代码来解决。

优化
广度搜索的判断重复如果直接判断十分耗时，我们一般借助哈希表来优化时间复杂度。
