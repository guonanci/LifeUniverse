https://baike.baidu.com/item/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2

开发爬虫早期使用较多的方法。他的目的是要达到被搜索结构的叶节点（即那些不包含任何超链的 HTML 文件）。在一个 HTML 文件中，当一个超链被选择后，被链接的 HTML 文件将执行深度优先搜索，即在搜索其余的超链结果之前必须先完整地搜索单独的一条链。深度优先搜索沿着 HTML 文件上的超链走到不能再深入为止，然后返回到某一个 HTML 文件，再继续选择该 HTML 文件中的其他超链。当不再有其他超链可选时，说明搜索已经结束。

图算法中的一种，Depth First Search.对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次

举例说明之：无向图，如果我们从 A 点发起 DFS（以下访问次序并不唯一，第二个点既可以是 B 也可以是 C，D）。我们可能得到如下的访问过程：A=>B=>E(没有路了，回溯到 A)CFHGD(没有路了回溯到 A，A 也没有未访问的相邻 lin 节点，本次搜索结束)。简要说明深度优先搜索的特点：每次深度优先搜索结果必然是图的一个连通分量。深度优先搜索可以从多点发起。如果将每个节点在深度优先搜索过程中的结束时间排序，具体做法是创建一个 list，然后在每个节点的相邻节点都已被访问的情况下，将该节点加入 list 结尾，然后逆转整个链表。则我们可以得到所谓的拓扑排序 topological sort

# 基本思路

深度优先遍历图的方法是，从图中某顶点 v 出发：

1. 访问顶点 v
2. 依次从 v 的从未被访问的邻接点出发，对图进行深度优先遍历，直至图中和 v 有路经相遇的顶点都被访问
3. 若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问为止。当然，当人们刚刚掌握深度优先搜索的时候常常用它来走迷宫，事实上我们还有别的方法，那就是广度优先搜索 BFS

# 穷举

有一些问题，我们不能确切找出数学模型，找不出一种直接求解的方法，这时候一般采用搜索：用问题的所有可能去试探，按照一定的顺序和规则不断去试探，直到找到解，还有可能无解，试探时，一定要试探完所有可能情况：-穷举

问题的第一个状态：初始状态，要求的状态是目标状态。搜索就是把规则用于初始状态，在其产生的状态中，直到得到一个目标状态为止。
产生新状态的过程叫 扩展(由一个状态，应用规则，产生一个新状态的过程)。搜索的要点：

1. 初始状态
2. 重复产生新状态
3. 检查新状态是否为目标，是结束，否转 2.

如果搜索是以接近起始状态的程序依次扩展状态的，叫宽度优先搜索；如果扩展是首先扩展新产生的状态，则叫深度优先搜索

深度优先搜索用一个数组存放产生的所有状态。
（1） 把初始状态放入数组中，设为当前状态；
（2） 扩展当前的状态，产生一个新的状态放入数组中，同时把新产生的状态设为当前状态；
（3） 判断当前状态是否和前面的重复，如果重复则回到上一个状态，产生它的另一状态；
（4） 判断当前状态是否为目标状态，如果是目标，则找到一个解答，结束算法。
（5） 如果数组为空，说明无解。

对于 pascal 语言来讲，它支持递归，在递归时可以自动实现回溯（利用局部变量）所以使用递归编写深度优先搜索程序相对简单，当然也有非递归实现的算法。 [3]

搜索是人工智能中的一种基本方法，是一项非常普遍使用的算法策略，能够解决许许多多的常见问题，在某些情况下我们很难想到高效的解法时，搜索往往是可选的唯一选择。按照标准的话来讲：搜索算法是利用计算机的高性能来有目的的穷举一个问题的部分或所有的可能情况，从而求出问题的解的一种方法。
搜索虽然简单易学易于理解，但要掌握好并写出速度快效率高优化好的程序却又相当困难，总而言之，搜索算法灵活多变，一般的框架很容易写出，但合适的优化却要根据实际情况来确定。在搜索算法中，深度优先搜索（也可以称为回溯法）是搜索算法里最简单也最常见的，今天我们就从这里讲起，下面的内容假设读者已经知道最基本的程序设计和简单的递归算法。

系统算法：
所有的搜索算法从其最终的算法实现上来看，都可以划分为两部分-控制结构和产生系统。正如前面所说，搜索算法简而言之就是穷举所有可能情况并找到合适的答案，
所以最基本问题就是罗列出所有可能情况，其实就是一种产生式系统.
我们将所有解答的问题划分成若干个阶段或步骤，当一个阶段计算完毕，下面往往有多种可选选择，所有选择共同组成问题的解空间，对搜索算法而言，将所有阶段
或步骤画出来就类似是树结构

从根开始计算，到找到位于某节点的解，回溯 su 法（dfs）作为最基本的搜索算法，采用「一直往下走，走不通就掉头」的思想（回溯），相当于采用了先根遍历方法
来构造搜索树

# 基本框架

```
.dfs(状态)
-if 状态 是 目标状态 then
.doSth
-else
.for 每个新状态
-if 新状态合法
>>dfs(新状态)
.主程序：
.dfs(初始状态)
```

堆叠：先进后出 C++的 STL
