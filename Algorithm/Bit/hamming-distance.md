# easy

https://leetcode-cn.com/problems/hamming-distance/ 461. 汉明距离
两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

注意：
0 ≤ x, y < 231.

示例:

输入: x = 1, y = 4

输出: 2

解释:
1 (0 0 0 1)
4 (0 1 0 0)
↑ ↑

上面的箭头指出了对应二进制位不同的位置。
通过次数 142,292 提交次数 176,312
请问您在哪类招聘中遇到此题？
贡献者
LeetCode
位 1 的个数
简单
汉明距离总和

# 前言

**汉明距离广泛应用于多个领域。在编码理论中用于错误检测，在信息论中量化字符串之间的差异。**
两个整数间的汉明距离是对应位置上数字不同的位数。
根据以上定义，我们使用异或运算，记为\oplus⊕，当且仅当输入位不同时输出为 1

计算 x 和 y 之间的汉明距离，可以先计算 x ⊕ y，然后统计结果中等于 1 的位数
现在，原始问题转换为位计数问题。位计数有多种思路，将在下面的方法中介绍。

# 1 内置位计数功能

大多数编程语言中都内置了计算二进制表达中 1 的数量的函数。工程中，我们应该直接使用内置函数

```cpp
class Solution {
public:
  int hammingDistance(int x,int y) {
    return __builtin_popcount(x^y)
  }
}
```

## 复

- 时：1 不同语言实现方法不一，我们可以近似认为时间复杂度为 1
- 空：1

# 2 移位实现位计数

在锻炼算法能力时，重复造轮子是不可避免的，也是应当的。所以读者们也许要尝试使用各种方法自己实现几个具有位计数功能的函数。本方法将使用位运算中移位的操作
实现位计数功能

具体地，记 s=x⊕y，我们可以不断检查 s 最低位，如果最低位为 1，那么令计数器加 1，然后我们令 s 整体右移一位，这样 s 最低位将被舍去，原本的次低位就
变成了新的最低位。我们重复这个过程直到 s=0 为止。这样计数器中就累计了 s 的二进制表示中 1 的数量

```js
var hammingDistance = function (x, y) {
  let x = x ^ y,
    ret = 0
  while (s != 0) {
    ret += s & 1
    s >>= 1
  }
  return ret
}
```

## 复

- 时 O(log C) C 是数据范围，本题中 logC = log 2^31 = 31
- 空 1

# 3Brian Kernighan

方法二中，对于 s=(10001100)2 的情况，我们需要右移 8 次才能得到答案，**如果我们可以跳过两个 1 之间的 0，直接对 1 进行计数，那么就只需要循环 3 次即可**
我们可以使用 Brian Kernighan 算法进行优化，描述为这样一个结论：**f(x)表示 x 和 x-1 进行与运算所得的结果（f（x）=x&（x-1））.那么 f（x）恰为 x 删去其二进制表示中最右侧的 1 的结果**

基于该算法，当我们计算出 s=x⊕y，只需要不断让 s=f（s），直到 s=0 即可。这样每循环一次，s 都会删去其二进制表示中最右侧的 1，最终循环次数即为 s 的
二进制表示中 1 的数量

Brain Kernighan 算法发布在 1988 出版的 The C Programming Language(Second Edition)的练习中（由 Brian W . Kernighan 和 Dennis M. Ritchie
编写，但是 Donald Knith 在 2006 年指出，该方法第一次是由 Peter Wegner 在 1960 的 CACM3 上出版。可以在上述书籍中找到更多位操作技巧

```js
var hammingDistance = function (x, y) {
  let s = x ^ y,
    ret = 0
  while (s != 0) {
    s &= s - 1
    ret++
  }
  return ret
}
```

## 复

- 时 logC 31
- 空 1
