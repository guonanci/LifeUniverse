# difficult

<https://leetcode-cn.com/problems/chalkboard-xor-game/> 810. 黑板异或游戏
黑板上写着一个非负整数数组 nums[i] 。Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）

换种说法就是，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，那么这个玩家获胜。

假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 true。

示例：

输入: nums = [1, 1, 2]
输出: false
解释:
Alice 有两个选择: 擦掉数字 1 或 2。

如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。
如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。

提示：

1 <= N <= 1000
0 <= nums[i] <= 2^16
通过次数 3,443 提交次数 5,246
请问您在哪类招聘中遇到此题？
贡献者
LeetCode
8

# 1 数学

按位异或运算
根据游戏规则，轮到某个玩家时，如果当前黑板上所有数字异或结果等于 0，则当前玩家获胜。由于 Alice 是先手，因此如果初始时黑板上所有数字异或结果等于 0，
则 Alice 获胜。
下面讨论初始时黑板上所有数字异或结果不等于 0 的情况：
**由于两人交替檫除数，且每次都擦掉一个数，因此对于两人中任意一人，每次在檫除数前，黑板上剩余数的个数奇偶性一定相同**

这启发我们从 nums 长度奇偶性来讨论。如果 nums 长度是偶数，先手 Alice 是否有可能失败呢
假设 Alice 失败，那么只有一种情况，既无论擦掉哪一个数字，剩余所有数字异或结果都等于 0

下面证明这不可能：设 nums 长度为 n，n 是偶数，S 为 nums 全部元素的 ⊕ 结果
那么
`S=nums[0] ⊕ nums[1] ⊕ ... ⊕ nums[n-1]` 不等于 0

Si 为擦掉 nums[i] 后，剩余所有数字的异或结果，则：
`Si⊕nums[i]=S`
等式两边同时 ⊕ nums[i]，由于对任意整数 x 都有 x ⊕ x = 0，得

`Si = S ⊕ nums[i]`
如果无论擦掉哪一个数字，剩余所有数字异或结果都等于 0，即对任意 0 <= i < n，都有 Si=0.因此对所有的 Si 异或结果也等于 0，
`S0 ⊕ S1 ⊕ ... ⊕ Sn-1 = 0`
将 `Si=S ⊕ nums[i]`代入，根据异或运算的交换和结合律化简，有

```js
0 == S0 ⊕ S1 ⊕ ...  ⊕ Sn-1
= (S ⊕ nums[0]) ⊕ (S ⊕ nums[1]) ⊕ ... ⊕ (S ⊕ nums[n-1])
= (S ⊕ S ⊕ ... ⊕ S) ⊕ (nums[0] ⊕ nums[1] ⊕ ... ⊕ nums[n-1])
= 0 ⊕ S
= S
```

上述计算中，第 3 行左括号为 n 个 S 异或，由于 n 是偶数，因此 n 个 S 异或结果是 0
根据上述计算，可以得到 S = 0，与实际情况 S 不等于 0 矛盾

**因此当数组长度是偶数时，先手 Alice 总能找到一个数字，在擦掉这个数字之后剩余的所有数字异或结果不等于 0**
在 Alice 擦掉这个数字后，黑板上剩下奇数个数，无论 Bob 擦掉哪个数，留给 Alice 的一定是黑板上剩下的偶数个数，此时 Alice 要么获胜，要么可以找到
一个数，在擦掉这个数之后剩余的所有数异或结果不等于 0，因此 Alice 总能立于不败之地。

同理可得，当数组长度是奇数时，Alice 在擦掉一个数后，留给 Bob 的一定是黑板上剩下偶数个数字。此时 Alice 要么获胜，要么仍可以找到一个一个数字，在
擦掉这个数字之后的所有数异或结果不等于 0.所以 Alice 总能立于不败之地。
同理可得，当数组长度是奇数时，Alice 在擦掉一个数后，留给 Bob 的一定是黑板上剩下偶数个数，所以 Bob 必胜。

综上所述，当且仅当以下两条件至少满足一个时，Alice 必胜：

- nums 全部元素异或结果等于 0
- nums 长度是偶数
  代码实现时，可以先判断 nums 长度是否为偶数，是就直接返回 TRUE。奇数时遍历 nums 计算全部元素的异或结果。nums 长度是偶数时只需要 O（1）即可得到答案。

```js
var xorGame = function (nums) {
  if (nums.length % 2 == 0) return true
  let xor = 0
  for (const ele of nums) {
    xor ^= ele
  }
  return xor == 0
}
```

# 复

- 时：O（n），n 是 nums 长度，最坏情况下，需要遍历数组一次，计算全部元素的异或结果
- 空：O（1）
