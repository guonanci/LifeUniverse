Fiber 是 React 16 中新的协调引擎或重新实现核心算法。它的主要目标是支持虚拟DOM的增量渲染。React Fiber 的目标是提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语。

React Fiber 的目标是增强其在动画、布局和手势等领域的适用性。它的主要特性是增量渲染:能够将渲染工作分割成块，并将其分散到多个帧中。



解决react旧版本，更新页面时会出现丢帧卡顿的问题
React旧版本问题
当我们调用setState更新页面的时候，React会遍历应用的所有节点，计算出差异，然后再更新 UI
整个过程是一气呵成，不能被打断的。如果页面元素很多，整个过程执行的时间可能超过 50 毫秒，就容易出现掉帧的现象
新版本解决方案
React Fiber是把一个大任务拆分为了很多个小块任务，一个小块任务的执行必须是一次完成的，不能出现暂停，但是一个小块任务执行完后可以移交控制权给浏览器去响应用户操作
核心是通过 requestIdleCallback ，会在利用浏览器空闲时间会找出所有需要变更的节点

阶段一，生成 Fiber 树，得出需要更新的节点信息，这一步是一个渐进的过程，可以被打断

阶段二，将需要更新的节点一次性批量更新，这个过程不能被打断

# react中使用了Fiber，为什么vue没有用Fiber？
原因是二者的更新机制不一样
Vue 是基于 template 和 watcher 的组件级更新，把每个更新任务分割得足够小，不需要使用到 Fiber 架构，将任务进行更细粒度的拆分
React 是不管在哪里调用 setState，都是从根节点开始更新的，更新任务还是很大，需要使用到 Fiber 将大任务分割为多个小任务，可以中断和恢复，不阻塞主进程执行高优先级的任务，如果不用Fiber，会出现老版本卡顿的问题



作者：海阔_天空
链接：https://juejin.cn/post/7146996646394462239
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

async rendering
https://segmentfault.com/a/1190000019095681
diff 算法和 virtual dom 完美结合的过程被称为 reconciler,有了 reconciler，开发者可以脱身操作真实的 dom 数，只需要向 react 描述界面的状态，而 react 会帮助你高效的完成真正的 dom 操作。
在 react16 之前的 reconciler 叫 stack reconciler，fiber 是 react 新的 reconciler，这次更新到 fiber 架构是一次重量级的核心架构的替换，react 为了完成这次替换已经准备了两三年的时间了。
在多数情况下，可能是因为浏览器忙着执行相关的 js 代码，导致浏览器主线程没有及时响应用户的操作或者没有及时更新界面。
因此 react 团队引入了异步渲染这个概念，而采用 fiber 架构可以实现这种异步渲染的方式。
原先的 stack reconciler 像是一个递归执行的函数，从父组件调用子组件的 reconciler 过程就是一个递归执行的过程，这也是为什么被称为 stack reconciler 的原因。当我们调用 setState 的时候，
react 从根节点开始遍历，找出所有的不同，而对于特别庞大的 dom 树来说，这个递归遍历的过程会消耗特别长的时间。在这个期间，任何交互和渲染都会被阻塞，这样就给用户一种“死机”的感觉。

https://heptaluan.github.io/2020/12/06/React/18/
react 核心机制是跟踪组件的状态变化，并将更新的状态映射到新的界面，在 React 中，我们将此过程称之为协调 Reconcilation，

默认情况下，JavaScript 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系，如果 JavaScript 运算持续占用主线程，页面就没法得到及时更新，当我们调用 setState 更新页面的时候，React 会遍历应用的所有节点，计算出差异，然后再更新 UI，整个过程一气呵成，不能被打断。如果页面元素很多，整个过程占用的时机就可能超过 16 毫秒,这是就容易出现掉帧的现象，也就是说，其根本原因是因为大量的同步计算任务阻塞了浏览器的 UI 渲染.

而 React 的 Reconcilation 是 CPU 密集型的操作，旧版 React 通过『递归』的方式进行渲染，使用的是 JavaSceipr 引擎自身的函数调用栈，它会一直执行到栈空为止，也就是比对 Virtual DOM 树，找出需要变动的节点，然后同步更新它们，这个过程 React 称为 Reconcilation（协调）

而 React 团队使用 Fiber 实现了自己的组件调用栈以后，它以链表的形式遍历组件树，可以灵活的暂停、继续和丢弃执行的任务，基本思路是将运算切割为多个步骤，分批完成，也就是说在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间进行页面的渲染，等浏览器忙完之后，再继续之前未完成的任务，所以使用 Fiber 架构的目的是让 Reconcilation 过程变成『可被中断』，适时地让出 CPU 执行权，让浏览器及时地响应用户的交互

Stack Reconcilier 的主要缺陷就是不能暂停渲染任务，也不能切分任务，无法有效平衡组件更新渲染与动画相关任务间的执行顺序，即不能划分任务优先级，有可能导致重要任务卡顿，动画掉帧等问题

Fiber Reconciler
而 React 16 版本提出了一个更为先进的协调器，它允许渲染进程分段完成，而不必须一次性完成，中间可以返回至主进程控制执行其他任务，而这是通过计算部分组件树的变更，并暂停渲染更新，询问主进程是否有更高需求的绘制或者更新任务需要执行，这些高需求的任务完成后才开始渲染

这一切的实现是在代码层引入了一个新的数据结构，也就是我们的 Fiber 对象，每一个组件实例对应有一个 Fiber 实例，此 Fiber 实例负责管理组件实例的更新，渲染任务及与其他 Fiber 实例的联系，这个新推出的协调器就叫做『纤维协调器』（Fiber Reconciler），它提供的新功能主要有下面这些

可切分，可中断任务
可重用各分阶段任务，且可以设置优先级
可以在父子组件任务间前进后退切换任务
render 方法可以返回多元素（即可以返回数组）
支持异常边界处理异常
下面就让我们来深入的了解一下，到底什么是 Fiber

那么什么是 Fiber 呢？其实 Fiber 是一种流程控制原语，它是一个非常底层的抽象描述，我们可以称其 协程 或者『纤程』，但是需要注意的是，协程和『线程』并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制，这里我们可以对比普通函数和 Generator 的运行方式，普通函数执行的过程中无法被中断和恢复，如下

```js
const tasks = []
function run() {
  let task
  while ((task = task.shift())) {
    execute(task)
  }
}
```

而 Generator 却是可以的：

```js
const tasks = []
function run() {
  let task
  while(task=task.shift()){
    if (hasHighPriorityEvent()) { // 判断是否有高优先级事件需要处理，有的话让出控制权
      yield
    }
  }
  execute(task) 处理完高优先级事件后，恢复函数调用栈，继续执行
}
```

所以我们可以发现，其实 React Fiber 的思想和协程的概念是契合的，也就是说 React 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染，那么这里你可能会有一个疑问，那就是 React 是如何将控制权交回浏览器的呢？其实浏览器并没有抢占的条件，通常来说是 React 主动让出机制，这是因为

一来浏览器中没有类似进程的概念，任务之间的界限很模糊，没有上下文，所以不具备中断或是恢复的条件
二则是没有抢占的机制，我们无法中断一个正在执行的程序，所以我们只能采用类似协程这样控制权让出机制
观察我们上面的代码，其实上面代码示例中的 hasHighPriorityEvent() 在目前浏览器中是无法实现的，因为我们没办法判断当前是否有更高优先级的任务等待被执行，从而让其让出机制，所以我们只能换一种思路，也就是通过『超时检查的机制』来让出控制权，即确定一个合理的运行时长，然后在合适的检查点检测是否超时（比如每执行一个小任务），如果超时就停止执行，将控制权交换给浏览器，而这个方式的实现主要依赖的是浏览器提供的 requestIdleCallback 这个 API

```js
window.requestIdleCallback(
  callback: (deadline: IdleDeadline)=>void, option?:{timeout:number}
)
interface IdleDeadline {
  didTimeout: boolean // 表示任务执行是否超过约定时间
  timeRemaining(): DOMHighResTimeStamp // 任务可供执行的剩余时间
}
```

让浏览器在有空的时候就执行我们的回调，这个回调会传入一个期限，表示浏览器有多少时间供我们执行.
我们最好在这个时间范围内执行完毕，现在我们知道了如何让出机制，那么浏览器什么时候有空呢？我们先来看一下浏览器在一帧（Frame，可以认为事件循环的一次循环）内可能会做什么事情，通常来说可能会做执行下列任务，而且它们的执行顺序基本是固定的

处理用户输入事件
JavaScript 执行
requestAnimation 调用
布局 Layout
绘制 Paint
通常，客户端线程执行任务时会以帧的形式划分，大部分设备控制在 30-60 帧是不会影响用户体验，在两个执行帧之间，主线程通常会有一小段空闲时间，requestIdleCallback 可以在这个『空闲期』（Idle Period）调用『空闲期回调』（Idle Callback）执行一些任务

但是在浏览器繁忙的时候，可能不会有盈余时间，这时候 requestIdleCallback 回调可能就不会被执行，所以在这种情况下可以通过 requestIdleCallback 的第二个参数指定一个超时时间

另外不建议在 requestIdleCallback 中进行 DOM 操作，因为这可能导致样式重新计算或重新布局（比如操作 DOM 后马上调用 getBoundingClientRect()），这些时间很难预估的，很有可能导致回调执行超时，从而掉帧

但是这个超时时间不是死的，低优先级的可以慢慢等待，高优先级的任务应该率先被执行，目前 React 预定义了五个优先级

Immediate（-1），这个优先级的任务会同步执行，或者说要马上执行且不能中断
UserBlocking（250ms），这些任务一般是用户交互的结果，需要即时得到反馈
Normal（5s），应对哪些不需要立即感受到的任务，例如网络请求
Low（10s），这些任务可以放后，但是最终应该得到执行，例如分析通知
Idle（没有超时时间），一些没有必要做的任务（比如隐藏的内容）

但是目前 requestIdleCallback 只有 Chrome 支持，所以为了支持其它浏览器，React 干脆自己 实现 了一个，它是利用 MessageChannel 模拟将回调延迟到绘制操作之后执行，如下图

React 应用中的基础单元是组件，应用以组件树形式组织，渲染组件
Fiber 协调器基础单元则是协调单元（协调器算法组成单元），应用以 Fiber 树形式组织，应用 Fiber 算法
组件树和 Fiber 树结构对应，一个组件实例有一个对应的 Fiber 实例
Fiber 协调器算法负责整个应用层面的协调，而 Fiber 实例则负责对应组件的协调

我们在之前提到过，旧版 React 是通过『递归』的方式进行渲染的，也就是说这是基于函数调用栈的协调算法，只不过这种依赖于调用栈的方式不能随意中断、也很难被恢复，不利于异步处理，这种调用栈，不是程序所能控制的，如果你要恢复递归现场，可能需要从头开始，恢复到之前的调用栈，所以针对于这种情况就需要对 React 现有的数据结构进行调整，模拟函数调用栈，将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代

React 目前的做法是使用链表，每个 VirtualDOM 节点内部现在使用 Fiber 表示，它的结构大概如下

export type Fiber = {
type: any, // Fiber 类型信息
return: Fiber | null, // 链表结构，指向父节点，或者 render 该节点的组件
child: Fiber | null, // 指向第一个子节点
sibling: Fiber | null, // 指向下一个兄弟节点
// ...
}
用图片来展示这种关系会更直观一些

Fiber 包含的属性可以划分为五个部分

结构信息，上面已经介绍过，Fiber 使用链表的形式来表示节点在树中的定位
节点类型信息，tag 表示节点的分类、type 保存具体的类型值，如 div、MyComp
节点的状态，节点的组件实例 props、state 等，它们将影响组件的输出
副作用，在协调过程中发现的副作用就保存在节点的 effectTag 中（类似打上标记），这里也使用了链表结构，将本次渲染的所有副作用节点都收集起来，通过 nextEffect 连接起来
workInProgress（WIP）树，React 在协调过程中会构建一颗新的树，可以认为是一颗表示当前工作进度的树，还有一颗表示已渲染界面的旧树，React 就是一边和旧树比对，一边构建 WIP 树的， alternate 指向旧树的同等节点

https://www.keisei.top/react-fiber-architecture/
