通过设置缓存策略，对常用不变的资源进行缓存；


当ETag和Last-Modified同时存在时，服务器优先检查ETag。

强缓存
强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的同时存在Expires 和 Cache-Control：max-age 时，哪个优先级高？Cache-Control：max-age优先级高，Cache-Control：max-age表示缓存内容在xxx秒后失效；Expires表示服务端返回的到期时间。Expires的缺点是：返回的是服务端时间，与客户端时间可能不一致。

Etag详解
为何Etag比last-modified优先级更高？

Cache-Control: no-cache 和no-store的区别
Cache-Control: no-cache：这个很容易让人产生误解，使人误以为是响应不被缓存，实际上Cache-Control: no-cache会被缓存，只不过浏览器每次都会向服务器发起请求，来验证当前缓存的有效性。Cache-Control: no-store，才是响应不被缓存的意思。

作者：海阔_天空
链接：https://juejin.cn/post/7146996646394462239
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# 1
定义，作用，分类，机制 – 如何构建有效利用 web 缓存的站点;
Html5， Web app，Web game 逐渐盛行，现代浏览器给我们提供哪些有利于 Web 缓存，提高访问效率的机制，前端的代码架构又能从哪些方面进行调整，更好的利用 Web 缓存。

what：
指一个 Web 资源存在于 Web 服务器和浏览器之间的副本。通过网络获取内容既缓慢，成本又高；大的响应需要在浏览器和服务器之间进行多次往返通信，拖延了很多时间。作用

Why：

- 减少带宽消耗，无论对于网站运营或者用户，带宽都代表着金钱，只会便宜网络运营商，当 web 缓存副本被使用时，只会产生极小流量，有效降低运营成本；

- 降低服务器压力，给资源设定有效期之后，用户可以重复使用本地缓存，减少对服务器请求，间接降低服务器压力，同时，搜索引擎的爬虫机器人能根据过期机制降低爬取频率，也能有效降低服务器压力。

- 减少网络延迟，加快页面打开速度。

kind：

- 数据库数据缓存

Web 应用，特别是 SNS 类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提高查询性能，会将查询后的数据放到内存中进行缓存，下次查询时直接从内存缓存返回，提高响应效率，比如说缓存方案 memcached

- 服务器端缓存

代理服务器缓存

代理服务器--浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起 Web 请求，经过处理后（权限验证，缓存匹配），再将请求转发到源服务器。代理服务器缓存运作原理
和浏览器运作原理差不多，只是规模更大。他其实是一个共享缓存，不止为一个用户服务，一般为大量用户提供服务。因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。常用的代理服务器缓存解决方案有 Squid。

CDN(content delivery networks),也叫做网关缓存，反向代理缓存

CDN 缓存一般由网站管理员自己部署，为了让网站更容易扩展并获得更好性能，浏览器先向 cdn 网关发起 web 请求，网关服务器后面对应着，一台或多台服务均衡源服务器，会根据他们的负载请求，动态地将请求状态，发到合适的源服务器上。

- 浏览器端缓存

根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。

Web 应用层缓存

从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况将数据存在文件系统或内存中，减少数据库查询或读写瓶颈，提高响应效率。

后续将从浏览器缓存机制，前端应用层缓存来讲讲。。。


# 2
与缓存相关的 http 首部字段主要有哪些？这些字段之间的联系与区别？它们之间的优先级、特点、与局限性；用户不同的页面刷新行为的差别；在实践中该用哪些报文头来控制缓存？

那些年与缓存相关的 http 首部字段 – 47种： 通用，请求，响应，实体；
1.0时代，给浏览器设定缓存：pragma 和 expires，为了 http的向下兼容，很多网站依旧会带上这俩个字段，腾讯课堂，调试者工具。。。

Cache-Control: public, max-age=86400
Pragma: no-cache
Pragma字段值为 no-cache的时候（事实上 RFC 也仅表明该可选值），会告知浏览器不要对该资源读缓存，每次都得向服务器发一次请求。
只有 IE 支持：`<meta http-equiv="Pragma" content="no-cache">`，但是如果在响应报文上加上该字段就会有效。

有了 pragma 来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间。
在HTML 里面加上`<meta http-equiv="expires" content="mon, 18 apr 2106 14:3000 GMT">`，同样也只有 IE 支持。。。所以说在响应报文上添加就可以有效启用缓存。
对1.0而言，expires 就是。。。他的值对应一个格林尼治时间 GMT，比如 Mon, 22 Jul 2002 11:12:01 GMT来告诉浏览器资源缓存过期时间，如果还没郭该时间点那么不发请求。
通过 Fiddler(charles)给图片资源额外加上以下头部信息：
Expires: Fri, 11 Jun 2021 11:33:01 GMT
重新访问该页面会发现访问图片资源的时候，会直接从缓村中读取资源内容，而不发起请求。
响应报文中expires 定义的缓存时间是想对服务器上的时间，如果浏览器和服务器上的时间不一致（用户修改了自己电脑的系统时间）的话，那么这个缓存时间就没有意义

- cache-control:

针对上述 时间不统一 的问题，1.1新增了 cache-control 来定义缓存过期时间。他也是一个通用首部字段：
Cache-Control: cache-directive
作为请求首部时， cache-directive 的可选值有：

作为响应首部，cache-directive的可选值有：

CC 允许自由组合可选值：
CC: max-age-3600, must-revalidate
他意味着该资源是从源服务器上取得。。。。当然这种组合的方式也会有一些限制，比如 no-cache 就不能和 max-age，min-fresh，max-stale 一起搭配使用
缓存校验字段
上述首部字段均能让浏览器决定是否向服务器发送请求，


客户端上某个资源保存的缓存时间过期了，但这时候其实服务器并没有更新过这个资源，如果这个资源数据量很大，客户端要求服务器再把这个东西重新发一遍过来，是否非常浪费带宽和时间呢？

答案是肯定的，那么是否有办法让服务器知道客户端现在存有的缓存文件，其实跟自己所有的文件是一致的，然后直接告诉客户端说“这东西你直接用缓存里的就可以了，我这边没更新过呢，就不再传一次过去了”。

为了让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，Http1.1新增了几个首部字段来做这件事情。

- Last-Modified

服务器将资源传递给客户端时，会将资源最后修改时间以Last-Modified：GMT的形式加在实体头部传动给客户端。
在第一次请求的响应头返回 Last-Modified 内容，时间格式如：Wed, 22 Jul 2009 07:08:07 GMT。是零时区的 GMT 时间。
客户端请求头会为资源标记上If-Modified-Since 内容，下次再次请求时，会把该信息附在请求报文中一并带给服务器去做检测对比，如果没有更新，直接返回304状态码即可。

Last-Modified 也有一个问题：如果服务器端资源被修改，但是仅仅是注释或者其他无所谓的修改，还是会触发修改时间，从而造成没必要的网络传输。

- ETag

为了解决上述无所谓修改问题，还退出了 ETag字段，服务器会通过某种算法，给资源计算的出一个唯一标识，通过 ETag 唯一标识返回浏览器，浏览器会保存该 ETag 字段，并在下一次请求时将其一并带过去给服务器，服务器只需要比较 ETag 是否一致，就可以很好地判断资源是否被修改过。


解决该困扰的办法也简单，把服务侧ETag的那一套也搬到前端来用，以版本形式发布页面的静态资源，常用的方法是在文件名或参数，带上一串md5或时间标记符：

https://hm.baidu.com/hm.js?e23800c454aa573c0ccb16b52665ac26
http://tb1.bdstatic.com/tb/_/tbean_safe_ajax_94e7ca2.js
http://img1.gtimg.com/ninja/2/2016/04/ninja145972803357449.jpg

如果文件被修改了，才更改其标记符内容，这样能确保客户端能及时从服务器收取到新修改的文件。


- 实践

一般通过 expires 来兼容旧浏览器，用 cache-control 来更精确地利用缓存，然后开启 ETag 和 Last-Modified 进一步复用缓存减少流量。
chrome  m.genshuixue.com -- index_aa28rjf2.css   那个就是200 OK from disk cache...实际上没有发请求，也不是Last-Modified或（和）ETag验证过的304，，，只是没有超过 Date + max-age  罢了。。。
如果 Last-Modified 和 ETag 同时启用，则需用两者都验证通过，才会返回304，否则重新请求并且返回200

#域名 定位的二级目录 资源  3种情况来系统性地介绍缓存？

首先what + why   then   how   if you don't understand it well   then i show how:  分享如何实践：  逐一解释 m.genshuixue.com各个字段   pragma   vary   x-cache??   etag   eagleld??打问号的都要 Google 一下！！！pragma public??


#其中   遇到重点或难点   用 Charles 来 打辅助，简单的就说说就可以，大家懂得差不多就行！！！


#要抓重点啊！！讲好玩好学好！！


#common：
Cache-Control 简称 CC，控制缓存的行为
Pragma 1.0的旧社会遗物，值为 no-cache 时禁用缓存
#request：
If-Match   比较 ETag 是否一致
告诉服务器如果没有匹配到ETag，或者收到了“*”值而当前并没有该资源实体，则应当返回412(Precondition Failed) 状态码给客户端。否则服务器直接忽略该字段。

If-Match 的一个应用场景是，客户端走PUT方法向服务端请求上传/更替资源，这时候可以通过 If-Match 传递资源的ETag。


If-None-Match   比较 ETag 是否不一致
If-Modified-Since 比较资源最后更新的时间是否一致
If-Unmodified-Since 比较资源最后更新的时间是否不一致



1. Vary

“vary”本身是“变化”的意思，而在http报文中更趋于是“vary from”（与。。。不同）的含义，它表示服务端会以什么基准字段来区分、筛选缓存版本。

我们先考虑这么一个问题——在服务端有着这么一个地址，如果是IE用户则返回针对IE开发的内容，否则返回另一个主流浏览器版本的内容。这很简单，服务端获取到请求的 User-Agent 字段做处理即可。但是用户请求的是代理服务器而非原服务器，且代理服务器如果直接把缓存的IE版本资源发给了非IE的客户端，这就出问题了。

因此 Vary 便是着手处理该问题的首部字段，我们可以在响应报文加上：

Vary: User-Agent
便能知会代理服务器需要以 User-Agent 这个请求首部字段来区别缓存版本，防止传递给客户端的缓存不正确。

Vary 也接受条件组合的形式：

Vary: User-Agent, Accept-Encoding
这意味着服务器应以 User-Agent 和 Accept-Encoding 两个请求首部字段来区分缓存版本。


2. Date 和 Age

HTTP并没有提供某种方法，来帮用户区分其收到的资源，是否命中了代理服务器的缓存，但在客户端，我们可以通过计算响应报文中的 Date 和 Age 字段来得到答案。

Date 理所当然是原服务器发送该资源响应报文的时间（GMT格式），如果你发现 Date 的时间与“当前时间”差别较大，或者连续F5刷新发现 Date 的值都没变化，则说明你当前请求是命中了代理服务器的缓存。

上述的“当前时间”自然是相对于原服务器而言的时间，那么如何获悉原服务器的当前时间呢？

常规从页面地址请求的响应报文中可获得，以博客园首页为例：


每次你刷新页面，浏览器都会重新发出这条url的请求，你会发现其 Date 值是不断变化的，这说明该链接没有命中缓存，都是从原服务器返回过来的数据。

因此我们可以拿页面上其它静态资源请求回包中的 Date 与其进行对比，若静态资源的 Date 早于原服务端时间，则说明命中了代理服务器缓存。

通常还满足这么个条件：

静态资源Age + 静态资源Date = 原服务端Date
这里的 Age 也是响应报文中的首部字段，它表示该文件在代理服务器中存在的时间（秒），如文件被修改或替换，Age会重新由0开始累计。

#response
ETag 资源的匹配信息
#entity
Expires 1.0的遗留物，实体主体过期时间
Last-Modified 资源的最后一次修改的时间

首部字段修改，有一些浏览器会自行给请求首部加上一些字段（chrome F5会强制加上‘cache-control: max-age=0’）mac 上面没有 F5强制刷新的功能。。。原来是command shift R
如果是选中 URL 地址栏并且按下回车键就不会加上 cache-control
手动修改请求或响应报文上的内容

很多网站对缓存一知半解，让相互依赖的资源出现竞态条件，从而无法同步更新。
最佳实践的俩种模式：

#模式1. 不变内容 + 长时间 max-age

Cache-Control: max-age=31536000
URL 对应的内容绝对不会改变，因此：
浏览器 / CDN 直接将这个资源缓存一年也没问题；

#模式2. 可变内容，每次都走服务端验证
cache-control： no-cache
URL 对应的内容可能会改变，所以没有服务端指示，不能使用本地缓存的任何版本；并不是不缓存，即使意味着使用缓存前必须检查这个资源在服务端是否有更新，no-store 告知浏览器完全不要缓存这个资源，must-revalidate 并不是说每次都要验证，只是某个资源在本地已缓存时长短于 max-age 指定时长时，可以直接使用否则就要发起验证。

这种资源，也可以给资源响应加上 ETag（资源的版本 ID），last-modified 这俩个头部，下次客户端请求这些资源时会通过 If-None-Match 或If-Modified-Since 这连个个请求头带上之前的值，这样服务端就可以返回304
##给可变内容加上 max-age 通常是错的。
让 service worker 和 http 缓存相互协作，而不是打架



[本文主要解决6个疑问](http://blog.csdn.net/liujunxin11/article/details/52043297)：
预缓存相关的 http 首部字段有哪些；
这些 http 首部字段之间的联系与区别；
http 缓存首部字段的优先级；
http缓存首部字段的特点与局限性；
用户不用的页面刷新行为的差别；
在实践中，我们该用哪些报文头来控制缓存？
##那些年与缓存相关的 http 首部字段

缓存头部对比
头部  优势和特点   劣势和问题
expires 1.0产物，可以在1.0和1.1中使用，简单易用；以时刻标识失效时间  时间是由服务器发送的，会出现服务器和浏览器时间不一致的问题；存在版本问题，到期之前的修改客户端不可知
cache-control 1.1产物，以时间间隔表示失效，解决了 expires服务器和浏览器相对时间的问题；比 expires 多了很多选项设置； 1.1才有的内容，不适用于1.0；存在版本问题，到期之前的修改浏览器不可知
last-modified   不存在版本问题，每次请求都会区服务器进行校验，服务器对比最后修改时间如果相同则返回304，不同则返回200以及资源内容。 只要资源修改，无论内容是都发生实质性的变化，都会将该资源返回浏览器。周期性重写，，这种情况下该资源包含的数据实际上一样的；以时刻作为表示，无法识别一秒内进行多次修改的情况；某些服务器不能精确的得到文件的最后修改时间

ETag 可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况；不存在版本问题，每次请求都会去服务器进行校验，计算 ETag 值需要性能损耗；分布式服务器存储的情况下，计算ETag 的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时发现 ETag 不匹配的情况

##用户刷新访问行为
在浏览器中，不同手段访问，刷新页面的速度不一样，有什么区别呢？

刷新/访问界面的手段分成3类：
在 URL 输入栏中输入然后回车/通过书签访问
F5、Command + R 点击工具栏中的刷新按钮、右键菜单重新加载
Ctrl + F5   command shift r

首次访问该网页，查看请求与响应信息可以看出请求头部没有任何关于 http 缓存相关的信息。而返回的 http response 包含了许多缓存相关头部字段。有缓存头部字段的资源，浏览器都会对它按照事先服务器设定的方式，进行一定程度的缓存，直到该文件过期，用户清空 cache，或者用户强制刷新资源时间。

然后 Command L， Enter，可以看到返回响应码是200 OK（from cache），浏览器发现资源已经缓存了，而且没有过期（通过expires 或者 cache-control），没有跟服务器确认，而是直接使用了浏览器缓存的内容。其中响应内容和之前的响应内容一模一样，例如其中的 date 是上一次响应的时间。
## 刷新按钮 Command R 右键菜单重新加载
和输入栏中敲回车不一样，此时会让浏览器如论如何都发一个 http request 给 server，即时先前的响应中有 expires 头部。cache-control: max-age=0是 chrome 强制加上的，if-modified-since 是因为获取该资源的时候包含了 last-mofigied 头部，浏览器会使用 if-modified-since 头部信息重新发送该时间已确认该资源是否需要重新发送，实际上 Server 没有修改这个资源，所以反悔了304，这样的响应信息很小，缩小好的route-trip不多，网页很快就刷新了。上面的例子中没有 ETag，如果 response 中包含 ETag，Command R 引发的 http request 也是会包含 if-none-match 的。实际上为了保证拿到的事 Server 最新的，不只是去掉了 if-modified-since、if-none-match，cache 不光只是存在 browser，中间节点proxy也有可能有 cache，为了防止获得的只是这些中间节点的 cache， chrome 又会给请求头部加上这两个字段：让中间的 cache 对这个请求失效，这样返回的绝对是新鲜的资源。
cache-control: no-cache
pragma: no-cache

## Command shift R
彻底从 Server 拿一份新资源过来，相当于把这个site的历史缓存全部清除，会发现跟我们第一次请求相比，相关的缓存控制时间字段也更新了

首先我们clear browsering data，然后首次访问 m.genshuixue.com；待会我们逐一研究我们 m 站首页主要用到的前几个资源的相关信息并用 Charles 来做一些验证，当然这个是 how，是后戏，首先我们要知道 what，why，要有前戏，前戏很重要。。。然后再研究 how。。。

# 缓存实践
综上对各种 http 缓存控制头部的对比以及用户可能出现的浏览器刷新行为的讨论，当我们在一个项目上做 http 缓存的应用时，我们实际上还是会把上述体积的大多数首部字段均使用上。
1。expires、cache-control
expires 用时刻来标识失效时间，不免受到时间同步的影响，而 cache-control 使用时间间隔很好的解决了这个问题。但是 CC 是1.1才有的，不适用于1.0，而 expires 既适用于1.0，也适用于1.1，所以说大多数挺狂下两个头同时发送汇泽一个更好的选择，当浏览器两种头都能使用的话会优先使用 CC。
2.last-modified、etag
两者都通过某个标识值来请求资源，如果服务器端资源没有变化，则自动返回304，内容为空，这样就节省了数据传输量
3.from-cache/304
expires和 cache-control 都有一个问题就是服务端座位的修改，如果还在缓存时效里，那么浏览器是不会去请求服务器资源的，这就存在一个资源版本不符的问题。。。

对于所有可缓存资源，指定一个 expires 或 CC max-age 以及一个 last-modified 或者 etag 至关重要。同时前者和后者可以很好的相互适应。
前者不需要每次都发去一次请求来校验资源时效性，后者保证当资源未出现修改的时候不需要发重新发送该资源。而在用户的不同刷新页面行为中，二者的结合也能很好的利用 http 缓存控制特性，无论是在地址栏输入 URI 还是输入回车进行访问，还是点击刷新按钮，浏览器都能充分利用缓存内容，进行不必要的请求与数据传输。

4.避免304
index.css文件实际上被命名为 index.css,expires 和 cache-control 时间出奇的长，难道不会导致用户无法得到其最近的内容嘛

其实是把服务端 etag 的那一套理论办到了前端来使用，页面的静态资源以版本形式发布，最常用的方法是在文件名或参数带上一串 md5或者 ts。有的在 uri 后面加上 md5参数，有的将 md5值作为文件名的一部分，有的将资源放在特性版本的目录中。文件没有变动的时候，浏览器就不用发起请求直接可以使用缓存文件；而在文件有变化的时候，由于文件版本号的变更，导致文件名变化，请求的 URL 变了，自然文件就更新了，这样就能确保浏览器能及时从服务器收到新修改的文件，通过这样的处理，增长了静态资源，特别是图片资源的缓存时间，避免资源很快过期，特别是图片资源的缓存时间，避免该资源很快过期，浏览器频繁向服务器发起资源请求，服务器再返回304响应的情况

#结论：
##需要兼容1.0的时候需要使用 expires，不然可以考虑直接使用 cache-control
##需要处理一秒内多次修改的情况，或者其他 last-modified 处理不了的情况，才使用etag,否则使用 last-modified
##对于所有可缓存资源，需要指定一个 expires 或者 cache-control，同时指定 last-modified 或者 etag
##可以通过标识文件版本名，加长缓存时间的方式来减少304响应

##header 取值
服务器在返回的 response 中主要使用两个 header 来控制浏览器的缓存行为： expires: 1.0版本中。。。绝对时间字符串；2.cachew-control: 1.1版本中定义，除了提供同 expires 相同并且更精确的缓存功能，还提供了验证机制，可以取值：
max-age ... 相对时间
no-cache: 提供了过期验证机制
no-store: 表示当前请求资源禁用缓存
private： 指示只有用户浏览器可以缓存，cdn 不可以
public： 用户浏览器和cdn 都可以。。。


chrome   disable-cache  会去掉 if-modified-since还有就是给cache-control和 pragma 字段加上no-cache，这样包括图片在内的各种资源都会200 OK。。。当然chrome 的插件还有 chrome 或者系统当中的 ttf 等字体文件还是从 disk cache 或者 memory cache。。。

这个相当于 Command shift R


当然这种组合的方式也会有些限制，比如 no-cache 就不能和 max-age、min-fresh、max-stale 一起搭配使用。组合的形式还能做一些浏览器行为不一致的兼容处理。例如在IE我们可以使用 no-cache 来防止点击“后退”按钮时页面资源从缓存加载，但在 Firefox 中，需要使用 no-store 才能防止历史回退时浏览器不从缓存中去读取数据，故我们在响应报头加上如下组合值即可做兼容处理：

Cache-Control: no-cache, no-store

##缓存检查表
不存在最佳的缓存策略，根据您的痛新模式，提供的数据类型以及应用特定的数据更新要求，必须定义和配置每个资源的设置以及整体的缓存层级。
在定义缓存策略时，要记住下列技巧和方法：

1. 使用一致的网址：如果你在不同的网址上提供相同的内容，将会多次获取和存储该内容。。。你说的一直的网址是域名一样吧。。。路径有可能不一样吧。。。
2. 确保服务器提供etag，通过验证令牌，如果服务器上资源未被修改，就不必传输相同的字节
3. 确定中继缓存可以缓存哪些资源：对所有用户的响应啊完全相同的资源很适合由 cdn 或者其他中继缓存进行缓存
4. 确定每个资源的最优缓存周期，不同的资源可能有不溶的更新要求，审查丙炔诶你多高每个资源适合的max-age
5. 确定网站的最佳缓存层级：对 HTML 文档组合使用包含内容指纹码的资源网址以及短时间或者 no-cache的生命周期，可以控制浏览器获取更新的速度

#Web 缓存工作原理：
所有的缓存都是基于一套规则来帮助它们决定什么时候使用缓存中的副本提供服务（假设有副本可用的情况下，未被销毁回收或者未被删除修改）。这些规则有的协议中有定义（如 http1.0和1.1），有的则是由缓存的管理员设置（如 DBA，浏览器的用户，代理服务器管理员或者应用开发者）
##浏览器端的缓存规则
对于浏览器端的缓存来讲，这些规则是在 http 协议头和 HTML 页面的 meta 标签中定义，他们分别从新鲜度和校验值两个维度来规定浏览器是否可以直接使用缓存中的副本，还是需要去源服务器获取更新的版本。

Web 开发者可以在 HTML 页面的 head 节点中加入 meta 标签，代码如下：
`<meta http-equiv="Pragma" content="no-cache">`
上述代码告诉浏览器当前页面不被缓存，每次缓存都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析 HTML 内容本身。

哪些请求不能被缓存？
无法被浏览器缓存的请求：
HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache，或Cache-Control:max-age=0等告诉浏览器不用缓存的请求
需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的
经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《HTTPS的七个误解》）
POST请求无法被缓存
HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存


##如何构建可缓存站点
- 同一个资源保证 URL 稳定性

URL是浏览器缓存机制的基础，所以如果一个资源需要在多个地方被引用，尽量保证URL是固定的。同时，比较推荐使用公共类库，比如Google Ajax Library等，有利于最大限度使用缓存

- 给Css、js、图片等资源增加HTTP缓存头，并强制入口Html不被缓存

对于不经常修改的静态资源，比如Css，js，图片等，可以设置一个较长的过期的时间，或者至少加上Last-Modified/Etag，而对于html页面这种入口文件，不建议设置缓存。这样既能保证在静态资源不变了情况下，可以不重发请求或直接通过304避免重复下载，又能保证在资源有更新的，只要通过给资源增加时间戳或者更换路径，就能让用户访问最新的资源

- 减少对Cookie的依赖

过多的使用Cookie会大大增加HTTP请求的负担，每次GET或POST请求，都会把Cookie都带上，增加网络传输流量，导致增长交互时间；同时Cache是很难被缓存的，应该尽量少使用，或者这在动态页面上使用。

- 减少对HTTPS加密协议的使用

通过HTTPS请求的资源，默认是不会被缓存的，必须通过特殊的配置，才能让资源得到缓存。建议只对涉及敏感信息的请求使用HTTPS传输，其他类似Css，Js，图片这些静态资源，尽量避免使用。

- 多用Get方式请求动态Cgi

虽然POST的请求方式比Get更安全，可以避免类似密码这种敏感信息在网络传输，被代理或其他人截获，但是Get请求方式更快，效率更高，而且能被缓存，建议对于那些不涉及敏感信息提交的请求尽量使用Get方式请求

- 动态CGI也是可以被缓存

如果动态脚本或CGI输入的内容在一定的时间范围内是固定的，或者根据GET参数相同，输入的内容相同，我们也认为请求是可以被缓存的，有以下几种方式，可以达到这个效果：
让动态脚本定期将内容改变时导出成静态文件，Web直接访问带有Last-Modified/Etag的静态文件
开发者可以通过代码给动态脚本的响应头中添加Cache-Control: max-age，告诉浏览器在过期前可以直接使用副本
通过代码给动态脚本的响应头添加Last-Modified/Etag信息，浏览器再次请求的时候，可以通过解析If-Modified-Since/If-None-Match得知浏览器是否存在缓存，由代码逻辑控制是否返回304

- 如何给站点增加缓存机制

HTTP请求/响应头中缓存报头对有效利用站点缓存，作为一个Web前端开发者，我要做什么呢？答案是：啥都不用做。不过要去推动Web运营人员、Web后端开发人员分别给服务器和动态脚本CGI增加合适的缓存报头。
服务器配置
Apache相关配置参考：mod_headers、mod_headers
编写可缓存的动态脚本
服务器配置的方法比较简单通用，但是如果遇到没有权限修改服务器配置或者需要添加更细致的Expires/Cache-Control/Etag等信息时，不妨可以试试从代码层面去添加这些信息。不同语言写法实现略有不同，但思路都是一致的。可以在单独开辟一个独立模块，调用语言库提供的添加报头的接口，根据需要设置报头信息。当某个请求的动态脚本需要被缓存时，可以采用类似include，require等模块引用方式调用公共模块，实现缓存机制。
Php实现代码实例如下：
```
Cache.php
<?php
Header(“Cache-Control: must-revalidate”);
$offset = 60 * 60 * 24 * 3;
$ExpStr = “Expires: ” . gmdate(“D, d M Y H:i:s”, time() + $offset) . ” GMT”;
Header($ExpStr);
?>
<?php
Require(Cache.php)
// business code here
// todo
?>
```

#HTML5时代的 web 缓存机制

随着现代浏览器的推动，Flash放弃对移动端的支持，HTML5无疑成为当前Web前端炙手可热的话题。各大游戏开发商、App开发商纷纷投入人力进行研究和技术储备。相信不久的将来，HTML5会迎来一个快速发展和普及的春天。那么，HTML5这个新一代的标准，又给我们带来哪些缓存机制呢？

- HTML5 之离线应用Manifest

我们知道，使用传统的技术，就算是对站点的资源都实施了比较好的缓存策略，但是在断网的情况下，是无法访问的，因为入口的HTML页面我们一般运维的考虑，不会对其进行缓存。HTML5的Cache Manifest离线应用特性就能够帮助我们构建离线也能使用的站点，所有的资源都使用浏览器本地缓存，当然前提是要求在联网的情形下使用过一次站点。

如何实现离线访问特性
实现的步骤非常简单，主要3个步骤：
1）在服务器上添加MIME TYPE支，让服务器能够识别manifest后缀的文件
AddType text/cache-manifest manifest
2）创建一个后缀名为.manifest的文件，把需要缓存的文件按格式写在里面，并用注释行标注版本
CACHE MANIFEST
# 直接缓存的文件
CACHE:
Path/to/cache.js
# version：2012-03-20
3）给 <html> 标签加 manifest 属性，并引用manifest文件
具体可以参考：HTML5 缓存: cache manifest
<html manifest=”path/to/name-of.manifest”>
离线应用访问及更新流程
第一次访问离线应用的入口页HTML（引用了manifest文件），正常发送请求，获取manifest文件并在本地缓存，陆续拉取manifest中的需要缓存的文件
再次访问时，无法在线离线与否，都会直接从缓存中获取入口页HTML和其他缓存的文件进行展示。如果此时在线，浏览器会发送请求到服务器请求manifest文件，并与第一次访问的副本进行比对，如果发现版本不一致，会陆续发送请求重新拉取入口文件HTML和需要缓存的文件并更新本地缓存副本
之后的访问重复第2步的行为
离线机制的缓存用途
从Manifest的机制来看，即使我们不是为了创建离线应用，也同样可以使用这种机制用于缓存文件，可以说是给Web缓存提供多一种可以选择的途径。
存在的问题：缓存文件更新控制不灵活
就目前HTML5提供的manifest机制来讲，一个页面只能引用一个manifest页面，而且一旦发现这个manifest改变了，就会把里面所有定义的缓存文件全部重新拉取一遍，不管实际上有没有更新，控制比较不灵活。针对这个问题，也有的同学提出了一些建议，比如把需要缓存的文件分模块切分到不同manifest中，并分开用HTML引用，再使用强大的iframe嵌入到入口页面，这样就当某一个模式需要有更新，不会导致其他模块的文件也重新拉取一遍。

- HTML5 之本地存储localstorage

HTML5给我们提供本地存储localstorage特性，严格来讲，其实已经不算传统Web缓存的范畴。因为它存储的地方是跟Web缓存分开的，是浏览器重新开辟的一个地方。
localstorage的作用
本地存储localstorage的作用主要使Web页面能够通过浏览器提供的set/get接口，存储一些自定义的信息到本地硬盘，并且在单次访问或以后的访问过程中随时获取或修改。
Localstorage的使用
Localstorage提供了几个非常易用的Api，setItem/getItem/removeItem/clear，具体的可以参考：Html5 Step by Step(二) 本地存储
Localstorage的缓存用途
Localstorage设计的本意可能是用来存储一些用户操作的个性化设置的文本类型的信息和数据，当我们其实也可能拿来当Web缓存区使用，比如我们可以将Base64格式编码的图片信息，存在localstorage中，再次访问时，直接本地获取后，使用Css3的Data:image的方式直接展现出来。
存在的问题：大小限制
按照目前标准，目前浏览器只给每个独立的域名提供5m的存储空间，当存储超过5m，浏览器就会弹出警告框。

可以说，HTML5的Manifest和localstorage是给我们在考虑Web缓存的时候提供了多一种思路，当你开发的应用只面对现代浏览器的时候，不妨可以考虑一下。

#web app 时代的缓存机制新思路


Web App常见架构
以WebQQ例，WebQQ这个站点的所有内容都是一个页面里面呈现的，我们看到的类似windows操作系统的框架，是它的顶级容器和框架，由AlloyOS的内核负责统筹和管理，然后其他模块，比如壁纸设置，消息中心，App Store都是以模块的形式，并用iframe的方式嵌入到顶级容器中。具观察，现在越来越多的Web应用都倾向于使用这个的架构，这样做好处是很明显的，比如顶级框架可以维持一个不变的javascript上下文便于管理；关闭模块的iframe后，内存可以更好的释放；利用iframe的安全机制最大限度的保证内核的安全和稳定等等。
这种Web的架构，其实也给我们Web前端提供了从代码逻辑层面上给Web应用实现缓存提供了可能。
缓存Ajax请求
由于顶级框架页面是不会由于调整刷新而导致javascript上下文丢失，所以底层或各个模块所需要的Ajax请求，都是可以通过顶级框架统一请求后，并以信息服务的形式对外提供Api调用。对于一些实时性要求不是很强的请求来说，可以由顶级框架做统一缓存，定期更新。这种做法可以不影响用户体验的前提下，明显减少请求数，降低网络流量，并间接减轻了服务器的压力。
通过Javascript实现内存缓存
跟缓存Ajax请求的结果类似，程序运行过程中的其他数据，其实也可以采用类似的方式在顶级容器的Javascript上下文中缓存。

Web App发展新方向：Web-Client模式
随着Web App的进一步发展，貌似浏览器已经无法阻挡Web应用探索更前端，更本地化Native App的用户体验。比如目前的Qplus、豆瓣荚等应用，都采用Client、Web相结合的开发模式。这样做即可以利用Web开发迭代更新快、UI开发成本低等特点，有可以利用客户端的能力为Web实现很多无法实现的功能。以Qplus为例，Qplus不但内嵌了Webkit内核，还未Webkit上定制了很多便利的接口，比如跨Web-Client的拖曳、多线程下载等。在这种发展新模式下，Web缓存又能有什么考虑的发张方向呢？
客户端提供缓存读写能力
我们知道，HTML5的localstorage仅仅只能支持5m的存储。我们可以按localstorage的设计思路，让客户端为Web定制更大，更灵活的本地存储功能。到时，Web缓存能做的事情就会更多。

以上就当前Web App的发展趋势，讨论了对于Web缓存领域，有哪些可以做，可以考虑的方向。当然，这些做法，合不合理，合不合适都还是值得讨论和商榷的，如果你有想法，都可以随时联系并一起讨论。

全文总结
本文尝试概述目前Web缓存方向的现状，以及HTML5和Web App时代下，Web缓存可以考虑的新方向。由于时间仓促和表达概括能力有限，有可能有表达不妥的地方，欢迎指正讨论。
历史
[Version 1.0] 2012-03-21 rehorn @ tencent webplus team

#hybrid app

# 简述浏览器缓存读取规则
浏览器缓存可以优化性能，比如直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，则使用缓存从而减少响应数据。

缓存位置
Service Worker
Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由缓存哪些文件、如何匹配缓存、如何读取缓存，而缓存是可持续性的。Service Worker 也是 PWA 的核心技术。

Memory Cache
Memory Cache 也就是内存中的缓存，主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据很高效，但是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

Disk Cache
Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。

在所有浏览器缓存中，Disk Cache 覆盖面基本上是最大的。它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache。

Push Cache
Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被时候用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂（大约 5 分钟）。

缓存过程分析
浏览器与服务器通信的方式为应答模式，即是：浏览器发起 HTTP 请求 - 服务器响应该请求。浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存表示存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源返回的响应头来确定的。

浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识；
浏览器每次拿到返回的请求结果都会将该结果和缓存表示存入浏览器缓存中；
